# 컴퓨터

## 1. 비트&#x20;

* 컴퓨터는 사실 수많은 비트의 모음이다.&#x20;
* 비트는 늘 ON, OFF 둘 중 한가지의 상태만 가진다.&#x20;
* 예
  * 전보는 전기의 전송키를 누르거나 누르지 않음으로써 메시지를 보내고, 이러한 메시지는 전기의 ON/OFF 신호로 바뀌어서 전송된다.&#x20;
  * 거실의 전등 - ON/OFF&#x20;



## 2. 게이트&#x20;

* 입력된 2개의 비트를 통해 1개의 새로운 비트 값을 반환하는 부품을 게이트라고 한다.&#x20;
* 컴퓨터는 이러한 게이트의 조합이다.&#x20;

### 2-1. NAND gate

* A와 B 두 개가 모두 켜져있어야 꺼지는 게이트&#x20;
* AND gate 와 반대이다.
* &#x20;![](<../../.gitbook/assets/image (1).png>)

### 2-2. NOT gate

* 입력과 반대의 결과를 출력하는 게이트&#x20;
* ![](<../../.gitbook/assets/image (5).png>)

### 2-3. AND gate&#x20;

* 두 입력값이 모두 존재하야만 켜지는 게이트&#x20;
* ![](<../../.gitbook/assets/image (4).png>)



{% hint style="info" %}
정리&#x20;

* AND : 둘 다 1을 입력해야 1을 반환. 나머지 경우에는 모두 0을 반환
* NOT : 1입력하면 0을, 0입력하면 1을 반환&#x20;
* NAND : 둘 다 1을 입력해야 0을 반환. 나머지 경우에는 모두 1을 반환&#x20;
{% endhint %}



## 3. 다이어그램

* 컴퓨터는 전기신호로 이루어지기 때문에 그 구조를 들여다본다고 해서 이해할수가 없다.&#x20;
* 이럴 때, 이용하기 가장 좋은 방법은 바로 다이어그램이다.&#x20;



## 4. 비트메모리&#x20;

* 비트메모리 1개 = NAND 4개만 있으면 만들 수 있다.&#x20;
* 4개의 NAND 게이트를 이용하면, 비트의 내용을 기억할 수 있다.&#x20;
* 기억하기 1. s가 on 일 때에는 입력값 i의 상태에 따라 결과값 o 가 정해진다.&#x20;
  * \= 전등이 켜지고 꺼지는 것이 입력된 스위치 값에 따라 달라진다.&#x20;
* 기억하기 2. s가 off일 때에는 마지막 입력값 i에 따라 출력된 o의 상태를 그대로 유지한다.&#x20;
  * \= s가 꺼져있다면, 전등은 이전 상태값을 기억하여 스위치의 입출력값에 상관없이 켜져있거나 꺼져있게 된다.&#x20;

## 5. 코드와 비트&#x20;

* 비트는 실제로 전기가 on인 상태와 off인 상태를 나타낼 뿐이다. 그러나 이러한 비트를 보아 게이트를 만들고, 게이트를 모아 비트메모리를 만들게 되면, 어떤 사물의 상태를 표현할 수 있게 된다.&#x20;
* 코드는 어떤 사물이 다른 사물을 의미하도록 만들어주는 방법이다. 이를 위해서는 어떤 사물에 들어있는 모든 상태와 다른 사물에 들어있는 모든 뜻을 하나씩 대응시켜 목록으로 만들어야 한다.&#x20;
* 예를 들어보자.&#x20;
  * 횡단보도에서 빨간불이 켜지면 보행자들은 멈추고, 빨간불이 꺼지면 보행자들은 횡단보도를 건너간다.&#x20;
  * 1이면 감자튀김을 넣고, 0이면 감자튀김을 기름에서 빼내라는 코드로 만들수도 있다.&#x20;
  * 모스부호, 전보처럼 0과 1의 신호만으로도 간단한 메시지를 주고 받을 수 있다. 물론 사전에 코드표를 정의하는 과정이 필요하다.&#x20;
* 비트 자체에는 의미가 없다. 그러나 비트와 행동을 연결시키면 의미를 가질 수 있다. 그것을 체계화 한 것이 바로 코드이다.&#x20;
* 진짜로 정교한 메시지를 주고 받기 위해서는 1비트만으로는 역부족이다. 1비트보다 많은 비트를 엮어서 사용하면, 보다 복잡한 표현도 구현해낼 수 있다.&#x20;
  * 3색 신호등은 3비트!
* 0과 1은 아무 의미가 없다. 의미는 인간이 정의하기에 따라서 달라질뿐이다. 다른 코드체계를 세우면 그만이다. &#x20;

## 6. 바이트&#x20;

* 바이트는 8개의 비트의 모음이며, 총 2^8 = 256개의 데이터를 표현할 수 있다.&#x20;
* 컴퓨터 코드는 결국 바이트의256가지 비트 패턴에다가 어떤 다른 것을 대응하기 위한 도구이다.&#x20;

## 7. 레지스터

* 레지스터 = 바이트 메모리 + 출력 제어기&#x20;
  * 6번까지 만든 바이트 메모리에 출력을 제어할 수 있게 AND 게이트 8개를 서로 엮어서 만든 출력 제어기를 합친다.&#x20;
  * 그러면 이제 이 부품은 입력된 값을 받고, 기억하며, 출력할지/말지도 결정할 수 있다.&#x20;
* 레지스터는 결국 간단하게 말하자면, 입력비트 8개의 상태를 기록하는 부품이다. 넉넉하지 않기 때문에 비싸기도 하다. 결국 새로운 상태를 저장하려면, 기존 바이트 상태를 덮어씌우게 되며, 레지스터에 남는 것은 가장 최근에 저장한 값일 뿐이다.&#x20;

## 8. 버스&#x20;

* 버스는 전선 다발을 의미한다. 옛날에 발전소 같은 곳에서 사용한 매우 두꺼운 전선을 가리키던 말 buss에서 유래한 단어이다.&#x20;
* 전선이 8개 있어야 1바이트 짜리 정보를 전달할 수 있고 이러한 전선 다발을 버스라고 하며, 이 버스를 통해서 다양한 장치로 비트가 보내진다.&#x20;
* 버스로 연결된 레지스터들은 바이트 데이터를 입력받을 때에는 2개 이상도 괜찮지만, 출력할 때에는 1개만 가능하다. 버스 내에서 데이터 간 충돌이 생겨서 모호한 데이터를 나타낼 수 있기 때문이다.&#x20;

## 9. 다중 입력 게이트와 다중 출력 게이트&#x20;

* 디코더는 입력에 대한 출력값이 입력시에 어떤 코드를 사용했는지 말해주는 것이다.&#x20;
* 디코더가 하는 일은 입력으로 받은 비트 상태에 해당하는 출력 하나만 1로 만들어주는 장치이다.&#x20;



## 10. 컴퓨터의 절반, 램&#x20;

* 가로 16 \* 세로 16 = 256개의 보관함
* 주기억장치는 컴퓨터를 만들 때 필요한 부품 절반을 차지하며, 여러 이름으로 불린다.&#x20;
* 주기억장치가 어떤 바이트에 접근하는 속도는 과거에 접근했던 주소에 영향을 받지 않는다. 과거 접근했던 주소가 현재 접근하려는 주소와 멀면 접근 속도가 느려지는 등의 일이 없다.&#x20;
* 그렇기에 무작위 접근 메모리, random access memory = RAM 이라는 이름을 갖게 되었다.&#x20;
* RAM 은 257개의 레지스터로 이루어져있다. 256개는 바이트를 저장하는데에 쓰이고, 1개는 저장장치에서 특정한 바이트의 위치를 가리키는데 사용된다. 이를 MAR, memory address register 라고 부른다.&#x20;
* MAR 이 표시할 수 잇는 주소의 길이를 늘려주기만하면, 언제든지 램 용량을 확장하고, 원하는 바이트에 접근할 수 있다. &#x20;

