---
title: 파이프라인과 백터처리 - 산술&명령어 파이프라인 
date: 2021-12-12 16:40:31
category: computer-architecture
---

> [패스트캠퍼스에서 컴퓨터 구조 강의](https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202104/161058-24/[패스트캠퍼스]-교육과정소개서-올인원-패키지---컴퓨터-공학-전공-필수.pdf) 를 듣고 스스로 공부한 내용을 정리하고 있습니다.

## 현실적인 파이프 라인의 구조 

### 실제 파이프라인 구조가 이론적인 최대 속도를 구현하지 못하는 이유 
앞서서 공부했던 바에 따르면, 파이프라인은 파이프라인을 사용하지 않았을때와 비교해서 엄청나게 큰 속도향상을 가져다 주었었다. 그렇다면, 현실적으로 파이프라인을 구현하더라도 이론적인 계산결과처럼 빠르게 동작할 것인가? **문제는 그렇지 않다는 점이다!** 왜 파이프라인은 계산된 이론의 결과처럼 최대속도를 구현하지 못하는 것일까?
- 각 세그먼트들이 부연산을 수행하는 시간이 서로 다르다. 
- 각 레지스터를 제어하는 클럭 사이클은 최대 전파시간을 갖는 세그먼트의 지연시간과 싱크를 맞추어야 한다. 
  - 가장 오래걸리는 세그먼트의 시간에 맞춰서 클럭 펄스를 주어야 한다. (클럭펄스 : 각 세그먼트의 계산결과를 다음 세그먼트로 일괄 이동시키는 신호)

### 파이프라인의 대안이 있을까? 
위와 같은 파이프라인 문제점들 때문에 현실세계에서 우리는 파이프라인의 대안을 생각하게 되는데 예를들면 `병렬적인 다중기능장치`를 고려해볼 수 있다. 

### 병렬적인 다중기능장치?
![img.png](/.gitbook/assets/computer-0901.png)
- 병렬적인 다중기능장치는 위의 그림으로부터 설명될 수 있다. 
- 각 P 회로는 전체 파이프라인 회로에서 동일하게 태스크를 수행하고
- 각 P의 처리 속도는 파이프라인의 처리속도와 같다고 가정한다.
- 그러나 이 구조는 순차적인 처리가 아니라, 모든 회로가 동시에 데이터를 입력받아서 네 태스크를 한번에 수행한다 
  - SIMD (Single Instruction Multi Data) 구조일뿐, 파이프라인 구조와는 다르다. 

> 파이프라인이 일반 순차적 처리구조보다 훨씬 효율적이다. 

## 파이프라인 구조가 적용되는 컴퓨터 설계
결국, 모든 상황에서 파이프라인이 더 빠르고 효율적인 것이 아니라. 파이프라인 구조가 효율적인 상황이 있는 것 같다. 
예를들면, 아래와 같은 설계구조에서는 파이프라인을 사용하는 것이 훨씬 효율적일 수 있다.

1. 산술 파이프 라인
2. 명령어 파이프 라인

## 산술 파이프 라인 
- 산술연산을 부연산으로 나누어 파이프라인의 세그먼트에서 수행한다. 
- 고속컴퓨터에서 부동소수점 연산, 고정 소수점 수의 곱셈, 과학계산용으로 활용
- 파이프라인 승산기
  - 배열승산기 : 부분 곱 사이의 캐리 전파시간의 최소화를 위한 가산기 
- 덧셈과 곱셈 등 각 연산의 노드들이 크게 다르지 않다. 

### 예시 : 부동소수점 덧셈과 뺄셈을 위한 파이프라인
![img_1.png](/.gitbook/assets/computer-0902.png)

두 개의 부동소수점 덧셈과 뺄셈을 위해서 파이프라인을 구축한다고 생각해보자. 

#### 우선 입력값과 각 세그먼트에서 처리될 연산을 생각한다. 
- 입력 : 두 개의 정규화 된 부동 소수점 이진수 (위의 이미지 참고)
- 각 세그먼트에서 수행되는 부연산 
  1. 지수를 비교하고
  2. 가수를 정렬한다. 
  3. 가수를 더하거나 빼고 
  4. 결과를 정규화한다. 

#### 각 세그먼트 부연산에 맞게 처리하기 
![img_2.png](/.gitbook/assets/computer-0903.png)

1. 초기 값 x, y를 설정하고 
2. Segment1 에서 각 지수를 비교한다. 
   1. 3이 2보다 크므로 3을 선택한다. 
3. Segment2 에서 지수를 맞추기 위해서 가수를 정렬한다. 
4. Segment3 에서 두 가수를 더하고 
5. Segment4 에서 결과를 실수 값으로 정렬한다. 

#### 파이프라인 vs. 비 파이프라인 효율성 비교 
![img_3.png](/.gitbook/assets/computer-0904.png)

위에서 우리가 구성한 Segment 1 ~ 4 까지가 부동 소수점의 파이프라인 조합회로들의 구성요소를 담고 있는 것이다. 
1. 비교기
2. 시프터
3. 가산/감산기
4. 인크리멘터 
5. 디크리멘터 

각 세그먼트들의 연산처리시간과 파이프라인을 사용했을 때, 비파이프라인을 사용했을 때를 각각 비교해보면, 총 소요시간은 약 3배정도 차이가 나는 것을 알 수 있다. 


## 명령어 파이프 라인
- 명령어 사이클의 fetch, 디코드, 실행단계를 중첩시킴으로 명령어 흐름에 동작
- 명령어 파이프라인은 이전 명령어가 다른 세그먼트에서 실행되고 있는 동안 메모리에 연속적으로 저장되어있는 다음 명령어를 읽어옴으로서 fetch 와 실행이 중첩되어 동시에 수행되는 구조이다. 
- 분기가 발생할 경우가 가장 큰 취약점이다. 
  - 현재의 파이프라인은 모두 비워져야하고, 분기명령 이후에 메모리에서 읽어온 명령어는 모두 무시되어야 한다. 

### 보다 효율적인 명령어 실행을 위한 파이프라인 구조는 
- 명령어 fetch 장치와 명령어 실행 장치로서 두 세그먼트 파이프라인을 경우 구성하는 컴퓨터를 고려해볼 수 있다. 
  - First In First Out 에 의한 Que 로 구성되어서 명령어 순서대로 실행되므로 메모리 참조에 의한 평균 메모리 접근 시간을 효과적으로 줄여줄 수 있다. 
- 명령어 파이프라인 실행시의 문제점이 있다면,
  - 세그먼트의 수행시간이 서로 다르고
    - 실행되지 않는 세그먼트도 있을 수 있다. 
  - 두 개이상의 세그먼트에 의해서 동일한 주소 공간이 참조될 수 있다. 

![img_4.png](/.gitbook/assets/computer-0905.png)
- 명령어 파이프라인은 분기명령에 가장 취약하다고 했었다.
- 분기명령어가 실행될 경우 branch 가 발생하게 되는데 (그림의 3번 스텝!) 분기명령을 접한 뒤에는 해당 파이프라인의 명령은 모두 비워지게 되고, 분기명령 이후의 명령어들은 모두 무시되게 된다. 
