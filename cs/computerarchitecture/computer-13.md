---
title: 메모리 구조 - 컴퓨터 성능 개선을 위한 메모리 관리 
category: computer-architecture
date: 2021-12-15 08:20:51
---

> [패스트캠퍼스에서 컴퓨터 구조 강의](https://fastcampus.co.kr/dev_online_computer) 를 듣고 스스로 공부한 내용을 정리하고 있습니다.

## Cache 메모리 전송을 위한 다양한 매핑 기법
캐시 메모리를 구현하고 활용하는 데에는 3가지 방법이 있었다. 
- associative mapping
- direct mapping
- set-associative mapping

### 예시 상황 설정 
다음과 같은 상황을 설정해보고 각각의 매핑기법이 어떻게 캐시 메모리를 구현하고 활용하는지 자세히 알아보도록 하자. 
우선, 현재 우리가 가진 메모리 스펙은 다음과 같다. 
- 주 기억장치인 main memory : 12bit 32K 워드를 저장 가능하다. 
- cache memory : 12bit 512 words 를 저장할 수 있고 주어진 시간 내에만 저장가능하다. 
- CPU 는 main memory, cache memory 두 곳과 모두 통신이 가능하다. 

이때, 15bit 의 주소를 입력받는다고 가정해보자. 
- cache 로 보내서 hit 가 발생하면, cache 로부터 12bit 의 데이터를 받는다. 
- miss 가 발생하면 주 기억장치인 main memory 로부터 words 를 읽고 cache 로 이동저장한다. 

### associative mapping
![img.png](/.gitbook/assets/computer-1301.png)
1. argument register 로 15비트의 CPU address 가 전달되면
2. hit 일 경우 : associative memory 내에서 주소와 같은 12bit 의 데이터를 읽어서 CPU 로 보낸다. 
   - Address : 각 숫자가 8진수이고 5자리이므로 32비트의 주소가 매핑됨 
   - Data : 각 숫자가 8진수 * 4자리 = 12비트의 데이터
3. miss 일 경우 : CPU 는 주 기억장치로 이동해서 해당 자료를 찾아 cache 로 옮긴다. 
4. 만약에 cache 가 꽉 차있다면, 특정 알고리즘에 의해 기존 cache 의 주소와 데이터 쌍이 새로운 쌍으로 대체된다. 
   - 특정 알고리즘은 여러가지가 있을 수 있지만, cache 자체가 지역성 locality 를 기반으로 모여져있는 데이터들이기 때문에 랜덤방식이 사용되기도 한다. = 특정 알고리즘을 사용하는 것과 성능상 큰 차이가 없기 때문
5. associative mapping 에서는 주소 뿐만 아니라 그 내용까지도 확인 가능 

### direct mapping 
![img_1.png](/.gitbook/assets/computer-1302.png)

- 일반 SRAM 구현되는 캐시 메모리
- RAM 에 구현된 메모리는 주소를 쪼개서 사용한다. : cpu address (15) = tag (6) + index (9)
- index field - cache 를 찾기 위한 제일 첫번째 주소체계로 활용되며, 우선 주소값을 찾을때 이 index 를 활용해서 검색을 하게 된다.  
- tag field - cache 에서 동일한 index 로 충돌이 발생할 때 활용한다. 
- 주의할 점
  - 보통 cache memory 를 구성할때, 약 90%의 히트율을 가지고 있지만 
  - 10%가 치명적일 경우 성능이 매우 저하될 수 있다. 
  - direct memory 에서도 동일 인덱스 + 다른 태그 를 보유한 워드가 반복하여 접근될 경우에는 히트율이 현저하게 떨어지게 된다. 

![img_2.png](/.gitbook/assets/computer-1303.png)
1. CPU Address 02000 전달됨
2. 000 인덱스를 기준으로 먼저 검색을 시작한다. -> 00 - 1220 을 발견후 접근한다. 
3. 태그값을 비교한다. -> 02 vs. 00 -> 태그가 달라서 miss 발생한다. 
4. CPU 는 주기억장치로 이동하여 02000 에 해당하는 데이터 5670 을 확인하고 캐시메모리로 이를 가져온다. 
5. cache index 000 값에 기존의 00-1220 값을 최근 access 했던 02-5670 으로 교체한다.   
   -> 이 작업이 반복적으로 일어날 경우, direct memory에서는 히트율이 현저하게 저하되고 성능이 저하된다. 

### set-associative mapping 
![img_3.png](/.gitbook/assets/computer-1304.png)

- cache 의 각 워드가 같은 인덱스(000) 주소 아래 두 개 이상의 메모리 워드를 저장할 수 있게 했다. 
  - direct mapping 의 최대 단점을 보완한 논리임! 
- 큰 규모의 cache 는 히트율을 높일 수 있겠으나, 좀 더 복잡한 비교 논리회로를 필요로 할 것 같다. 
  - 단순히 index 비교 후 -> tag 비교 논리가 아니라, index 로 검색 후 각 index 가 가지고 있는 모든 tag 를 비교해야 하기 때문
- 기존 데이터를 신규 데이터로 바꾸는 대체 알고리즘이 direct mapping 보다 복잡해진다. 

## 가상 메모리 
- 가상 메모리 : 물리적 기억공간보다 더 큰 기억공을 마치 존재하는 것처럼 활용할 수 있는 개념

### virtual memory vs. cache memory 
- 필요성
  - 전체 메모리 시스템의 총 비용을 최소화하면서 
  - 가능한 메모리로 높은 평균 접근 속도를 위해서 활용된다. 
- 설치위치 
  - 가상메모리 : 보조기억장치와 주 기억장치 사이에서 데이터 전송을 관리한다. 
  - 캐쉬메모리 : 주 기억장치와 CPU 사이에서 정보를 교환한다. 
- 사용목적
  - 가상메모리 : CPU 에 의해 현재 사용되고 있지 않은 자료 및 프로그램을 보관한다. 
  - 캐쉬메모리 : 가장 사용빈도가 높은 프로그램 및 데이터를 저장, 활용한다.
- 활용 방안 
  - 가상메모리
    - 페이지를 사용하는 주소 매핑 
    - Associative memory 페이지 표 
    - 페이지 교체 
  - 캐시메모리
    - direct mapping 
    - associative mapping 
    - set-associative mapping 

## 메모리 관리 하드웨어
### 등장배경
- 메모리가 점점 그 역할 및 사용방법이 세분화되면서 개념적으로 굉장히 크고 넓어지게 되었다. 
- 게다가 프로그램도 점차 발달하면서 
- 시스템 내 상호 간섭이 발생하는 것이 시스텀 기능 저하요인의 중요한 부분으로 자리잡게 되었다. 
  - ex) 복잡해지면서 접근시간이 들어난다던가 
- 프로그램과 프로그램 사이의 데이터 흐름, 선후 데이터의 활용, 사용메모리의 양 조절, 다른 프로그램의 흐름에 영향을 끼치지 못하게 하는 제어 등 메로리를 관리해줄 수 있는 시스템이 필요로하게 되면서 메모리 관리 시스템이 등장하게 되었다. 
- 메모리 내의 여러 프로그램의 관리하기 위한 하드웨어와 소프트웨어 절차의 집합체이며 운영체제의 일부라고 할 수 있다. 

### 메모리 관리 하드웨어 
- 논리 메모리 참조를 물리 메모리 주소로 변환하는 동적 저장장소 재배치를 위한 기능
  - 예를들면, 파이프라인에서 데이터를 동시에 접속하거나 기존 연산때문에 시간이 지연되는 등의 문제를 방지하기 위해서 프로그램을 저장하는 메모리와 데이터를 저장하는 메모리를 분리해서 관리하도록 했었던 것. 이때 이 분리하는 기능을 메모리 관리 하드웨어가 할 수 있는 것이다. 
- 메모리 내에서 서로 다른 사용자가 하나의 프로그램을 같이 사용하기 위한 편의성을 제공
- 사용자 간의 허락되지 않은 접근을 방지하고 사용자가 OS 의 기능을 변경하지 못하도록 하는 정보의 보호 

