---
title: 파이프라인과 벡터처리 - 데이터의 종속성 - 병렬처리와 파이프라인 
date: 2021-12-08 06:53:04
category: computer-architecture
---

> [패스트캠퍼스에서 컴퓨터 구조 강의](https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202104/161058-24/[패스트캠퍼스]-교육과정소개서-올인원-패키지---컴퓨터-공학-전공-필수.pdf) 를 듣고 스스로 공부한 내용을 정리하고 있습니다.

컴퓨터 구조 수업을 들으면서 CPU 성능이 갈수록 발전하고 좋아지는 부분을 배우고 있는데, 사실 중요한 것은 컴퓨터 CPU의 성능이 좋아지는 것 그 자체가 아니라, 이것을 잘 활용해서 좋고 효율적인 프로그램을 만드는 것이다. 이 점을 기억하면서 병렬처리와 파이프라인에 대해서 알아보자! 

## 병렬처리
병렬처리는 컴퓨터 시스템의 계산속도를 향상시키기 위해서 동시 데이터 처리 기능을 제공하는 광범위한 개념의 기술을 의미하는데, 쉽게 말하자면 지금보다 빠르게 데이터를 처리할 수 있는 방법이 없을까? 라는 고민의 결과라고 할 수 있다. 
병렬처리는 복잡도에 따라서 다양한 단계가 있다고 한다.

1. 사용 레지스터 형태에 따른 병렬성 구현
   - 시프트 레지스터
   - 워드 당 동시에 전송이 가능한 병렬성을 갖는 레지스터
   - 예) 입출력 정보를 입력받고 출력할 때에는 직렬로 받지만, 데이터를 처리할 때에는 병렬적으로 처리한다. (입출력 부분 내용 참고)
2. 특정한 동작을 동시에 수행하는 여러 개의 기능장치를 가지고서 데이터를 각각의 장치에 분산시켜 작업을 수행
   - 예를들면, 산술, 논리, 시프트 동작을 각각 세 개의 장치로 분류하고 제어 장치의 관리에 따라서 게산된 값들을 각 장치들 사이에서 전환시킨다. 
   ![img.png](/.gitbook/assets/computer-07-01.png)
   - 위의 그림의 경우도, 덧셈, 곱셈, 시프트 등 특정한 동작을 수행하는 기능장치들이 존재하고 각각의 장치에 분산시켜서 작업을 수행하게 된다.
   - 만약에 결과를 그 다음 연산에서 가져다가 쓸 경우에는 어떻게 해야할까?
     - 해당 로직은 필요한 값이 다른 연산 결과로부터 도출될때까지 기다릴 수 밖에 없다. 병렬처리의 효율성을 이용하지 못하고 있는 셈! 
     - 해결방법
       - 이때는 각각의 기능장치 내부에 accumulator 라는 레지스터를 하나 더 두어서 매 번 연산의 결과를 누적해서 저장하는 방법이 있다. 
       - 다른 기능에서 해당 연산 결과가 필요하면 그때그때 accumulator 를 뒤져서 제일 최신 계산된 결과값을 가져가도록! 
       - 단점? 매우 로직이 복잡해지게 됨

### M.J Flynn 의 분류방법
이 방법은 무엇인가 획기적인 대안을 제기했다기 보다는, 우리가 지금 쓰고 있는 방법을을 외형적으로 분류한 것이다. 
(명렁어의 흐름 -> 메모리로부터 읽어온 명령어의 순서, 데이터 흐름 -> 데이터에 대해 수행되는 동작)에 따라 컴퓨터 시스템의 구조를 파악하려는 분류방법을 제안했다. 

- SISD
  - 제어장치, 처리장치, 메모리장치를 가지는 단일 컴퓨터 구조
  - 명령어들은 순차적으로 실행되고, 병렬처리는 다중 기능장치나 파이프 라인 처리에 의해서 구현된다. 
- SIMD 
  - 한 개의 명령어에 여러 개의 제어장치
  - 공통의 제어장치 아래에 여러개의 처리 장치를 두는 구조
  - 모든 프로세서는 동일한 명령어를 서로 다른 데이터 항목에 대하여 실행시킬 수 있다. 
  - 모든 프로세서가 동시에 메모리에 접근할 수 있도록 다중 모듈을 가진 공유 메모리 장치가 필요하다. 
  - 아직 해결해야하는 문제들이 많으므로, 계속 연구되고 있는 개념이다. 
- MISD
  - 이론적으로만 연구되고 실제로 구현된 적은 없음
  - 양자컴퓨터가 일상화 된다면 가능성이 있을수도...?
- MIMD
  - 여러 프로그램을 동시에 수행하는 능력을 가진 컴퓨터 시스템
  - 대부분의 다중 프로세서와 다중 컴퓨터 시스템이 이 범주에 속한다. 
  - 요즘 우리가 쓰고 있는 컴퓨터의 유형이 바로 이 분류에 해당한다! 

하지만 위에서도 말했듯, 위의 4가지 분류방법은 말 그대로 `현재 우리가 어떻게 병렬처리를 사용하고 있는가` 에 대한 분류이자 현황파악 정도인데, 이 4 가지 분류에 포함되지 않지만 현재 우리가 활발히 사용하고 있는 것이 바로 `파이프라인`이다. 


## 파이프라인
### 구조와 성능
파이프라인의 동작은 공간과 시간표에 의해 설명될 수 있다. 시간에 대한 함수로서 세그먼트의 사용상황을 보여주는 그림을 통해서 좀 더 자세히 이해를 해보자. 

![img_1.png](/.gitbook/assets/computer-07-02.png)

상황 가정
- 위의 그림에서는 n개의 작업을 파이프라인을 통해서 동시에 수행을 하고 있다고 가정한다. 
- 이때 일정한 길이의 세그먼트 파이프라인이 k개 있고,
- 하나의 세그먼트 파이프라인 내에서 하나의 작업이 완료되는데 드는 시간인 클럭사이클에 tp의 시간이 든다고 가정해보자. 

계산
- 첫번째 작업인 T1 이 작업을 완료하는데 소요되는 시간은 k*tp 만큼의 시간이 소요된다. 
- 나머지 태스크의 소요시간은 (n-1)tp
- 결국, k개의 파이프라인에서 n개의 작업을 수행하는데 소요되는 시간은 
- `ktp + (n-1)tp` = `(k+n-1)tp` = `(k+n-1)` 개의 클럭사이클이 필요하다는 것을 알 수 있다. 

예를들면,
- 4개의 세그먼트 파이프라인이 있고, 6개의 작업을 수행해야한다면 
- 각 파이프 라인 내에서 하나의 작업을 수행하는데 필요한 클럭사이클은 `4+(6-1)=9` 임을 알 수 있다.


### 만약 파이프라인을 사용하지 않는다면? 
- 각각의 작업을 완료하는데 드는 시간 : tn
- n개의 작업을 수행하는데 드는 시간 : n*tn
- 테스트의 양인 n이 무한대로 증가한다고 생각해보면, 파이프라인을 썼을때와 안썼을때의 처리속도 차이는 아래와 같음 
- ![img.png](/.gitbook/assets/computer-07-04.png)

